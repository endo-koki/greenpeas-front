import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../app/store';

/** -1: suggested, 0: included, 1: excluded, 2: default */
export type DateState = -1 | 0 | 1 | 2;
export type MipStatus =
  | 'CUTOFF'
  | 'ERROR'
  | 'FEASIBLE'
  | 'INFEASIBLE'
  | 'INT_INFEASIBLE'
  | 'LOADED'
  | 'NO_SOLUTION_FOUND'
  | 'OPTIMAL'
  | 'UNBOUNDED';
/** init: 初期状態, ready: サーバと通信できてsuggestionを計算していない状態, pending: 計算中, 計算終了はMipStatus */
export type CalcState = 'init' | 'ready' | 'pending' | MipStatus;
export interface allDateState {
  memMat: string[][];
  dateArr: DateState[];
  memList: string[];
  allDateList: string[];
  calcState: CalcState;
}

const initialState: allDateState = {
  memMat: [],
  dateArr: [],
  memList: [],
  allDateList: [],
  calcState: 'ready',
};

export const allDateSlice = createSlice({
  name: 'allDate',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // set functions
    setData: (state, action: PayloadAction<string[][]>) => {
      const rawMat: string[][] = action.payload;
      const memMat: string[][] = [];
      const allDateList: string[] = [];
      for (let i = 1; i < rawMat.length; i++) {
        const rawVec: string[] = rawMat[i];
        allDateList.push(rawVec[0]);
        memMat.push(rawVec.slice(1));
      }

      state.memMat = memMat;
      state.memList = rawMat[0].slice(1);
      state.allDateList = allDateList;
      state.dateArr = new Array(allDateList.length).fill(2);
      state.calcState = 'ready';
    },
    /** idxのdateStateをincluded→excluded→default→…と変化させる */
    switchDate: (state, action: PayloadAction<number>) => {
      const idx: number = action.payload;
      const currentValue: DateState = state.dateArr[idx];
      state.dateArr[idx] = ((currentValue + 1) % 3) as DateState;
    },
    setCalcState: (state, action: PayloadAction<CalcState>) => {
      state.calcState = action.payload;
    },
    suggestDate: (state, action: PayloadAction<number>) => {
      const idx: number = action.payload;
      const currentValue: DateState = state.dateArr[idx];
      if (currentValue === 2) {
        state.dateArr[idx] = -1;
      }
    },
    clearSuggestion: (state) => {
      state.dateArr.forEach((val, idx) => {
        if (val === -1) {
          state.dateArr[idx] = 2;
        }
      });
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
});

export const {
  setData,
  switchDate,
  setCalcState,
  suggestDate,
  clearSuggestion,
} = allDateSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectMemMat = (state: RootState) => state.allDate.memMat;
export const selectDateArr = (state: RootState) => state.allDate.dateArr;
export const selectMemList = (state: RootState) => state.allDate.memList;
export const selectAllDateList = (state: RootState) =>
  state.allDate.allDateList;
export const selectCalcState = (state: RootState) => state.allDate.calcState;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default allDateSlice.reducer;
